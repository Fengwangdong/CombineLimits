/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "CombineLimits/Limits/interface/Erf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooErf) 

 RooErf::RooErf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _shift,
                        RooAbsReal& _scale) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   shift("shift","shift",this,_shift),
   scale("scale","scale",this,_scale)
 { 
 } 


 RooErf::RooErf(const RooErf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   shift("shift",this,other.shift),
   scale("scale",this,other.scale)
 { 
 } 



Double_t RooErf::evaluate() const 
{ 
    // Erf goes from -1 to 1
    // We want from 0 to 1
    double result = 0.5 * TMath::Erf(scale * (x-shift)) + 1;
 	return result;
} 

Int_t RooErf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if (matchArgs(allVars,analVars,x)) return 1 ;
  return 0 ;
}

Double_t RooErf::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code==1);

  double xmax = x.max(rangeName);
  double xmin = x.min(rangeName);

  // integration by parts
  // u = erf(x), dv = dt
  double uv = xmax * (0.5*TMath::Erf(xmax)+1) - xmin * (0.5*TMath::Erf(xmin)+1);
  double intvdu = -1. *  (TMath::Exp(-TMath::Power(xmax,2)) - TMath::Exp(-TMath::Power(xmin,2))) / TMath::Sqrt(TMath::Pi());

  // erf(scale*(x-shift)) -> erf(x) with a factor of 1/scale
  double result = (uv - intvdu)/scale;

  return result;
}

