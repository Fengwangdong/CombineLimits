/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "CombineLimits/Limits/interface/DoubleSidedVoigtian.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include <complex>
#include "TMath.h" 
#include "RooMath.h"
#include "RooVoigtian.h"

ClassImp(DoubleSidedVoigtian) 

DoubleSidedVoigtian::DoubleSidedVoigtian(const char *name, const char *title, 
                       RooAbsReal& _x,
                       RooAbsReal& _mean,
                       RooAbsReal& _sig1,
                       RooAbsReal& _sig2,
                       RooAbsReal& _wid1,
                       RooAbsReal& _wid2) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  sig1("sig1","sig1",this,_sig1),
  sig2("sig2","sig2",this,_sig2),
  wid1("wid1","wid1",this,_wid1),
  wid2("wid2","wid2",this,_wid2)
{ 
} 


DoubleSidedVoigtian::DoubleSidedVoigtian(const DoubleSidedVoigtian& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  sig1("sig1",this,other.sig1),
  sig2("sig2",this,other.sig2),
  wid1("wid1",this,other.wid1),
  wid2("wid2",this,other.wid2)
{ 
} 



Double_t DoubleSidedVoigtian::evaluate() const 
{ 
  double C1 = 1 / (2 * TMath::Sqrt(2.0)*sig1); // the additional / 2 is to normalize the double Voigtian to 1
  double C2 = 1 / (2 * TMath::Sqrt(2.0)*sig2); // the additional / 2 is to normalize the double Voigtian to 1
  Double_t A1 = 0.5*C1*wid1;
  Double_t A2 = 0.5*C2*wid2;
  Double_t U1 = C1*(x-mean);
  Double_t U2 = C2*(x-mean);
  std::complex<Double_t> Z1(U1,A1) ;
  std::complex<Double_t> Z2(U2,A2) ;
  std::complex<Double_t> voigt(0.) ;
  std::complex<Double_t> Z1_at_mean(0,A1) ;
  std::complex<Double_t> Z2_at_mean(0,A2) ;
  std::complex<Double_t> voigt1_at_mean = RooMath::faddeeva(Z1);
  std::complex<Double_t> voigt2_at_mean = RooMath::faddeeva(Z2);
  double integral_difference = voigt1_at_mean.real() - voigt2_at_mean.real();
  double total_integral = 1.0 + integral_difference * (25 - mean);	
  if ( x < mean)
  {
    voigt = RooMath::faddeeva(Z1);
    return C1 * voigt.real() / TMath::Power(TMath::Pi(), 0.5) / total_integral;
  }//if
  else
  {
    voigt = RooMath::faddeeva(Z2);
    return ((C2 * voigt.real() / TMath::Power(TMath::Pi(), 0.5)) + integral_difference) / total_integral;
  }//else

} 



