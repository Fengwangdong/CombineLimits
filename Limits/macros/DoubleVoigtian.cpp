/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "DoubleVoigtian.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include <complex>
#include "TMath.h" 
#include "RooVoigtian.h"

ClassImp(DoubleVoigtian) 

DoubleVoigtian::DoubleVoigtian(const char *name, const char *title, 
                       RooAbsReal& _x,
                       RooAbsReal& _mean,
                       RooAbsReal& _sig1,
                       RooAbsReal& _sig2,
                       RooAbsReal& _wid1,
                       RooAbsReal& _wid2) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  sig1("sig1","sig1",this,_sig1),
  sig2("sig2","sig2",this,_sig2),
  wid1("wid1","wid1",this,_wid1),
  wid2("wid2","wid2",this,_wid2)
{ 
} 


DoubleVoigtian::DoubleVoigtian(const DoubleVoigtian& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  sig1("sig1",this,other.sig1),
  sig2("sig2",this,other.sig2),
  wid1("wid1",this,other.wid1),
  wid2("wid2",this,other.wid2)
{ 
} 



Double_t DoubleVoigtian::evaluate() const 
{ 
  double V1 = 1/(TMath::Sqrt(2.0)*sig1);
  double V2 = 1/(TMath::Sqrt(2.0)*sig2);
  Double_t A1 = 0.5*V1*wid1;
  Double_t A2 = 0.5*V2*wid2;
  Double_t U1 = V1*(x-mean);
  Double_t U2 = V2*(x-mean);
  std::complex<Double_t> Z1(U1,A1) ;
  std::complex<Double_t> Z2(U2,A2) ;
  std::complex<Double_t> voigt(0.) ;

  if ( x < mean)
  {
    voigt = RooMath::faddeeva(Z1);
    return V1 * voigt.real() / TMath::Power(TMath::Pi(), 0.5);
  }//if
  else
  {
    voigt = RooMath::faddeeva(Z2);
    return V2 * voigt.real() / TMath::Power(TMath::Pi(), 0.5);
  }//else

} 



